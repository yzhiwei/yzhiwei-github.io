<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[图论]]></title>
    <url>%2Fyzhiwei.github.io%2F2019%2F07%2F29%2F%E5%9B%BE%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[基本概念根据边的方向： 有向图，无向图 路径： 从某个点出发经过若干条边到达另一个点 简单路径： 不重复经过某个点的路径 度数： 无向图中一个点连出去边的个数 连通： 两个点通过路径相连 拓扑图： 没有环的图 存图邻接矩阵邻接表利用stl里的vector存图 将点i的出边，存在一个vector数组中 12345678#define maxn 5250 //最大点数; struct node&#123; int to,v; //to代表到哪个顶点，v代表权值&#125;; vector&lt;node&gt; e[maxn]; //每个点都有自己的邻接表，vector是一个node类型的数组 插入边1234567void addedge(int u,int v,int w) //u-&gt;v = w;&#123; node tmp; tmp.to = v; tmp.v = w; e[u].push_back(tmp); //关于顶点u的邻接表&#125; 遍历1234for(int i = 0; i &lt; e[1].size(); i++) //遍历1号顶点所有出边&#123; cout&lt;&lt;1&lt;&lt;e[1][i].to&lt;&lt;e[1][i].v&lt;&lt;endl;&#125; 最短路问题https://blog.csdn.net/qq_36386435/article/details/77403223?tdsourcetag=s_pctim_aiomsg v1给定一张n个点m条边的有向图，每条边的长度为1，求1号点到其他点的最短路径 如果1到x的最短路为L,那么肯定存在一个y，使得1到y的最短路为L-1，且y到x有边。 用队列维护这个拓展的过程 时间复杂度 O（n+m） 1234567while(!q.empty())&#123; for(x,y) push(y); if(d[y]&gt;d[x]+1)&#123; d[y]=d[x]+1;&#125;&#125; v2给定一张n个点m条边的有向图，每条边的长度为1或0，求1号点到其他点的最短路径 改一下bfs 如果两点间距离为0，则将这两点合并（并查集） if w(x,y)=0;father[x]=y; v3给定一张n个点m条边的有向图，每条边的长度为1或2，求1号点到其他点的最短路径 把长度为2的边拆为长度为1的边 w(x,y)=w(x,z)+w(z,y) v4给定一张n个点m条边的正权有向图，求1号点到其他点的最短路径 按照最短路的大小从小到大加入队列，用优先队列进行维护 时间复杂度：O(n+mlogn) 或 O(n^2+m) 不能处理带负权的边 1234567891011121314151617181920212223242526272829const int inf=1&lt;&lt;29;int map[1010][1010];//map[i][j]表示从i--&gt;j的距离 int dist[1010];//dist[i]从v1到i的距离 int vis[1010];//标记有没有被访问过 void dijkstra(int n)&#123; int k,min; for(int i=1; i&lt;=n; i++) &#123; dist[i]=map[1][i]; vis[i]=0; &#125; for(int i=1; i&lt;=n; i++)//遍历顶点 &#123; k=0; min=inf; for(int j=1; j&lt;=n; j++) if(vis[j]==0&amp;&amp;dist[j]&lt;min) &#123; min=dist[j]; k=j; &#125; vis[k]=1; for(int j=1; j&lt;=n; j++) if(vis[j]==0&amp;&amp;dist[k]+map[k][j]&lt;dist[j]) dist[j]=dist[k]+map[k][j];//如果找到了通路就加上 &#125; return;&#125; v1-v4带有贪心策略的广度优先搜素 bellman-ford给定一张n个点m条边的有向图，求1号点到每个点的最短路 每次拿每条边去更新最短路 时间复杂度 O(n*m) 1234567for(int k=1;k&lt;=n-1;k++)&#123; for(int i=1;i&lt;m;i++)&#123; if(dis[v[i]]&gt;dis[[u[i]]]+w[i])&#123; dis[v[i]]=dis[u[i]]+w[i]; &#125; &#125;&#125; SPFAbellman-ford的优化 对于一条边(u,v),在dis[u]没变的情况下不应该重新更新 用队列记录要进行拓展的点，每次dis[x]被更新后就把x扔进队列里去更新其他点的最短路 123456789101112131415161718192021222324252627const int maxn=1000;int n,m,src;vector&lt;pair&lt;int,int&gt;&gt; g[maxn];int dis[maxn];bool inque[maxn];queue&lt;int&gt; que;void spfa()&#123; memset(dist,63,sizeof(dist)); dis[src]=0; while(!que.empty()) que.pop(); que.push(src); inque(src)=true; while(!que.empty())&#123; int u=q.front(); que.pop(); for(int i=0;i&lt;g[u].size;i++)&#123; if(dist[u]+g[u][i].second&lt;dist[g[u][i].first])&#123; dist[g[u][i].first]=dist[u]+g[u][i].second; if(!inque[g[u][i].first])&#123; inque[g[u][i]].first=true; que.push(g[u][i].first); &#125; &#125; &#125; inque[u]=false; &#125;&#125; 卡SPFA建一个n*m的网格图，其中行数很少，列数很多 行与行的边权都较小，列与列的边权都较大 判断负环记录len[x],表示1到x的最短路的点的个数，len[x]&gt;=n时存在负环 时间复杂度 O(n*m) floyd给定一张n个点m条边的有向图，求每两个点之间的最短路 f(K,X,Y)表示x到y的路径中，满足路径上的点标号都不超过k的最短路径 动态规划进行松弛操作 f(K,X,Y)=min(F(K-1,X,Y),f(k-1,X,K)+f(K-1,K,Y)) 1234567for(int k=0;i&lt;n;i++)&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; f[i][j]=min(f[i][j],f[i][k]+f[k][i]); &#125; &#125;&#125; 时间复杂度O(n^3) 差分约束问题假设对于一张图来说，1号点到x的最短路长度为d[x] 则有 d[y]&lt;=d[x]+w[x][y]; 最短路可以给出这类问题的最大解，取反后记得最小解 对于解不等式，有很多解 对于存在负环的图，无解 提供了一种判断差分约束问题有无解的方法,判断是否存在负环 给定n,m和m个三元组(l,r,k),求一个01串s,使得s[l…r]中1的个数至少有k个，求1最少的满足条件的01串 将区间和用前缀和表示 设f[i]为s[1…i]中1的个数 f[i]&lt;=f[i-1]+1;f[i-1]&lt;=f[i];f[l-1]&lt;=f[r]-k; 次短路定义：若d[v]=d[u]+w(u,v),则称(u,v)是最短路图上的边 1—-u—-v—-n 1-u和v-n都是最短路 枚举边w(u,v),若d(u) &lt; d[v]+w(u,v),则uv不是最短路上面的边 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;using namespace std;const int R = 100000+5;const int INF = 0x3f3f3f3f;struct Node&#123; int v; int w; int next;//存储前一个点在数组的位置&#125; edge[R*2]; int head[R];//存储最后一个点每个点在的数组位置int dist1[R],dist2[R];//距离数组，分别求1到所有点距离和n到所有点距离bool vis[R];int num;int n,m; void init()&#123; num = 0; memset(head,-1,sizeof(head)); memset(dist1,0x3f,sizeof(dist1)); memset(dist2,0x3f,sizeof(dist2));&#125; void add_edge(int u,int v,int w)//邻接表&#123; edge[num].v = v; edge[num].w = w; edge[num].next = head[u]; head[u] = num++;&#125; void SPFA(int u,int *dist)//u是给定点 dist是距离数组&#123; int i,v,w; queue&lt;int&gt; Q; memset(vis,false,sizeof(vis)); dist[u] = 0; vis[u] = true; Q.push(u); while(!Q.empty()) &#123; u = Q.front(); Q.pop(); vis[u] = false; for(i=head[u]; i!=-1; i=edge[i].next) &#123; v = edge[i].v; w = edge[i].w; if(dist[v] &gt; dist[u] + w) &#123; dist[v] = dist[u] + w; if(!vis[v]) &#123; vis[v] = true; Q.push(v); &#125; &#125; &#125; &#125;&#125;int main()&#123; while(scanf("%d%d",&amp;n,&amp;m)!=EOF)//n个点，m条边 &#123; int u,v,w;; init(); for(int i=1; i&lt;=m; i++) //无向图，双向间图 &#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add_edge(u,v,w); add_edge(v,u,w); &#125; SPFA(1,dist1);//求 1 到所有点的最短路 SPFA(n,dist2);//求 n 到所有点的最短路 int ans = INF; for(int i=1; i&lt;=n; i++)//遍历每个点 &#123; for(j=head[i]; j!=-1; j=edge[j].next)//与i点相连的边 &#123; v = edge[j].v; w = edge[j].w; // 1 到 i这一点的最短路， n 到 j这一点的最短路 + edge[i][j] int tem = dist1[i] + dist2[v] + w; if(tem &gt; dist1[n] &amp;&amp; tem &lt; ans) &#123; ans = tem; &#125; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; 图的连通性无向图的连通： 两个点存在一条连接的路径 连通块： 里面的点两两连通的块 连通具有传递性，不连通不具有传递性。 维护连通性对于每个连通块维护一个有根树，f(x)表示x的根 假设我们添加一条边u,v,首先求出u,v所在连通块的有根树树根x,y,然后令f(x)=y 桥对于一个连通无向图，定义1条边(u,v)是桥,当且仅当断开这条边后图变得不连通 强连通分量： 没有桥的连通块 dfn:表示顶点在dfs中的遍历顺序low：不通过父节点能访问到的祖先节点中最小的顺序值 tarjan123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;struct node &#123; int v,next;&#125;edge[1001];int DFN[1001],LOW[1001];int stack[1001],heads[1001],visit[1001],cnt,tot,index;void add(int x,int y)&#123; edge[++cnt].next=heads[x]; edge[cnt].v = y; heads[x]=cnt; return ;&#125;void tarjan(int x)//代表第几个点在处理。递归的是点。&#123; DFN[x]=LOW[x]=++tot;// 新进点的初始化。 stack[++index]=x;//进站 visit[x]=1;//表示在栈里 for(int i=heads[x];i!=-1;i=edge[i].next) &#123; if(!DFN[edge[i].v]) &#123;//如果没访问过 tarjan(edge[i].v);//往下进行延伸，开始递归 LOW[x]=min(LOW[x],LOW[edge[i].v]);//递归出来，比较谁是谁的儿子／父亲，就是树的对应关系，涉及到强连通分量子树最小根的事情。 &#125; else if(visit[edge[i].v ])&#123; //如果访问过，并且还在栈里。 LOW[x]=min(LOW[x],DFN[edge[i].v]);//比较谁是谁的儿子／父亲。就是链接对应关系 &#125; &#125; if(LOW[x]==DFN[x]) //发现是整个强连通分量子树里的最小根。 &#123; do&#123; printf("%d ",stack[index]); visit[stack[index]]=0; index--; &#125;while(x!=stack[index+1]);//出栈，并且输出。 printf("\n"); &#125; return ;&#125;int main()&#123; memset(heads,-1,sizeof(heads)); int n,m; scanf("%d%d",&amp;n,&amp;m); int x,y; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); add(x,y); &#125; for(int i=1;i&lt;=n;i++) if(!DFN[i]) tarjan(1);//当这个点没有访问过，就从此点开始。防止图没走完 return 0;&#125; 无向图求割点和桥割点：无向连通图中，去掉一个定点和它相邻的所有边，图中的连通分块增加 桥：去掉一条边，图中的连通分量数增加 有割点不一定有桥 桥一定是割点依附的边 割点：如果一个点的所有孩子节点可以不通过父亲节点直接访问到祖先节点，那么这个点不是割点 桥：low[v]&gt;dnf(u),就说明v-u是桥 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;using namespace std;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#define N 201vector&lt;int&gt;G[N];int n,m,low[N],dfn[N];bool is_cut[N];int father[N];int tim=0;void input()&#123; scanf("%d%d",&amp;n,&amp;m); int a,b; for(int i=1;i&lt;=m;++i) &#123; scanf("%d%d",&amp;a,&amp;b); G[a].push_back(b);/*邻接表储存无向边*/ G[b].push_back(a); &#125;&#125;void Tarjan(int i,int Father)&#123; father[i]=Father;/*记录每一个点的父亲*/ dfn[i]=low[i]=tim++; for(int j=0;j&lt;G[i].size();++j) &#123; int k=G[i][j]; if(dfn[k]==-1) &#123; Tarjan(k,i); low[i]=min(low[i],low[k]); &#125; else if(Father!=k)/*假如k是i的父亲的话，那么这就是无向边中的重边，有重边那么一定不是桥*/ low[i]=min(low[i],dfn[k]);//dfn[k]可能！=low[k]，所以不能用low[k]代替dfn[k],否则会上翻过头了。 &#125;&#125;void count()&#123; int rootson=0; Tarjan(1,0); for(int i=2;i&lt;=n;++i) &#123; int v=father[i]; if(v==1) rootson++;/*统计根节点子树的个数，根节点的子树个数&gt;=2,就是割点*/ else&#123; if(low[i]&gt;=dfn[v])/*割点的条件*/ is_cut[v]=true; &#125; &#125; if(rootson&gt;1) is_cut[1]=true; for(int i=1;i&lt;=n;++i) if(is_cut[i]) printf("%d\n",i); for(int i=1;i&lt;=n;++i) &#123; int v=father[i]; if(v&gt;0&amp;&amp;low[i]&gt;dfn[v])/*桥的条件*/ printf("%d,%d\n",v,i); &#125; &#125;int main()&#123; input(); memset(dfn,-1,sizeof(dfn)); memset(father,0,sizeof(father)); memset(low,-1,sizeof(low)); memset(is_cut,false,sizeof(is_cut)); count(); return 0;&#125; 欧拉回路给定一张有向图，如何求出一条经过每条边恰好一次的回路 必要条件： 1.这张图是一个强联通分量 2.每个点出度等于入度 这两个条件同时也是充分的 圈套圈算法 任选一个起点，从起点开始dfs,每个边只能被走一遍，当没有边走的时候把x压入答案的队列中。 dfs(x){ for(x,y) dfs(y) x—ans} 最后求出的是一个反着的欧拉回路 树树：n个点n-1条边的连通无向图，分为有根树和无根树 树的叶子：度数为0的点 最小生成树给定一张n个点的带权无向图，求权值最小的生成树 kruskal算法： 将边按照权值大小排序，之后能加就加，用并茶几维护 prim算法： 按照点进行贪心 证明：数学归纳法，假设法 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=5000;int father[maxn];int sum;struct node&#123; int start,ed,power;&#125;e[maxn];int cmp(node a,node b)&#123; return a.power&lt;b.power;&#125;int find(int x)&#123; return father[x]==x?x:find(father[x]);&#125;int join(int x,int y,int z)&#123; int fx=find(x); int fy=find(y); if(fx!=fy)&#123; father[fx]=fy; sum+=z; &#125;&#125;int main(int argc, char const *argv[])&#123; int n; while(cin&gt;&gt;n)&#123; sum=0; for(int i=0;i&lt;n;i++) father[i]=i; for(int i=0;i&lt;n;i++) cin&gt;&gt;e[i].start&gt;&gt;e[i].ed&gt;&gt;e[i].power; sort(e,e+n,cmp); for(int i=0;i&lt;n;i++) join(e[i].start,e[i].ed,e[i].power); cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125; prufer序列将一棵树变成一个序列 每次选择树上标号最小的叶子，删掉它，将与它相连的那个点的标号加到序列里，直到只剩下两个点。 可以证明：任意一个长度为n-2的1…n的序列都是某颗树的prufer序列 二分图可以分成两部分，使得这两部分内部没有边的图 一个图是二分图等价于该图没有奇环 二分图的匹配一个匹配是一个边的集合，其中任意两条边都没有公共顶点 最大匹配：一个图所有匹配中，所含匹配边数最多的匹配 完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，就是一个完美匹配 完美匹配：所有男孩和女孩都配对，使的每对都相互喜欢 最大匹配：最多有多少互相喜欢的男孩/女孩 交替路：从一个未匹配点出发，依次经过非匹配边，匹配边…形成的路径 增广路，从一个未匹配点出发，走交替路，如果途径另一个未匹配点，则这条交替路成为增广路。 https://blog.csdn.net/ling_wang/article/details/79830980 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int inf=0x3f3f3f3f;const int maxn = 10005;int edge[maxn][maxn];//edge[i][j] == 1 代表i，j可以匹配int vis[maxn];//用来记录该点是否被访问过int cx[maxn], cy[maxn];//用来记录x集合中匹配的y元素是哪个int nx, ny;//nx表示x集合的顶点个数， ny表示y集合的顶点个数int line(int u)&#123; int v; for(v = 0; v &lt; ny; v++)&#123; if(edge[u][v] &amp;&amp; !vis[v])&#123; vis[v] = 1; if(cy[v] == -1 || line(cy[v]))&#123;//如果y集合中的v没有匹配或v已经匹配，但从cy[v]中可以找到一条增广路 cx[u] = v;//找到增广路，修改匹配 cy[v] = u; return 1; &#125; &#125; &#125; return 0;&#125;int maxmatch()&#123; int sum = 0, i; memset(cx, 0xff, sizeof(cx));//初始值为-1表示两个集合中都没有匹配的元素 memset(cy, 0xff, sizeof(cy)); for(i = 0; i &lt;= nx; i++)&#123; if(cx[i] == -1)&#123;//还没被匹配就执行内部代码 memset(vis, 0, sizeof(vis));//重置标记为未访问 sum += line(i);//以 i 为起点开始查找增广路，返回true ，匹配数+1 &#125; &#125; return sum;&#125;int main()&#123; int x, y, t; while(scanf("%d", &amp;t) &amp;&amp; t)&#123; scanf("%d%d", &amp;nx, &amp;ny); memset(edge, 0, sizeof(edge)); for(int i = 0; i &lt; t; i++)&#123; scanf("%d%d", &amp;x, &amp;y); edge[x][y] = 1; &#125; int sum = maxmatch(); printf("%d\n", sum); &#125; return 0;&#125; 二分图染色1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt;g[200005];//通过邻接表的方式存储可以存入更多的点int color[200005];//存储当前点的颜色int bfs(int u);int main()&#123; int n,m,x,y,i; cin&gt;&gt;n&gt;&gt;m; for(i=0;i&lt;n;i++) &#123; g[i].clear(); color[i]=0;//初始化，表示当前点未染色 &#125; for(i=0;i&lt;m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); g[x].push_back(y); g[y].push_back(x); &#125; if(bfs(1))printf("YES\n"); else printf("NO");&#125;int bfs(int u)&#123; queue&lt;int&gt;q; q.push(u); color[u]=1; while(!q.empty()) &#123; int t=q.front(); q.pop(); for(int i=0;i&lt;g[t].size();i++) &#123; if(color[g[t][i]]==color[t])return 0;//如果当前点和该点相连的另一点的颜色相同，那么证明该图不是二分图 else if(!color[g[t][i]])//如果不相等，且当前点未染色，那么进行染色，并将该点推入队列中 &#123; color[g[t][i]]=-color[t]; q.push(g[t][i]); &#125; &#125; &#125; return 1;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[牛客多校第二场]]></title>
    <url>%2Fyzhiwei.github.io%2F2019%2F07%2F29%2F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%8C%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[题目链接： https://ac.nowcoder.com/acm/contest/882#question F题目]]></content>
      <tags>
        <tag>多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用mathjax渲染latex公式]]></title>
    <url>%2Fyzhiwei.github.io%2F2019%2F07%2F22%2F%E4%BD%BF%E7%94%A8mathjax%E6%B8%B2%E6%9F%93latex%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[卸载默认的渲染引擎1npm uninstall hexo-renderer-marked --save 安装hexo-renderer-kramed引擎1npm install hexo-renderer-kramed --save 改变文件配置打开/node_modules/hexo-renderer-kramed/lib/renderer.js 123456789101112// Change inline math rulefunction formatText(text) &#123; // Fit kramed&apos;s rule: $$ + \1 + $$ return text.replace(/`\$(.*?)\$`/g, &apos;$$$$$1$$$$&apos;);&#125;为，直接返回text// Change inline math rulefunction formatText(text) &#123; return text;&#125; 卸载hexo-math1npm uninstall hexo-math --save 安装hexo-renderer-mathjax包1npm install hexo-renderer-mathjax --save 更改默认转义规则reason：latex语法与markdown语法有冲突 打开/node_modules\kramed\lib\rules\inline.js 将123escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,改为escape: /^\\([`*\[\]()# +\-.!_&gt;])/, 123em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,改为em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 最后需要letex公式时，在头部加入1mathjax： true]]></content>
  </entry>
  <entry>
    <title><![CDATA[latex公式总结]]></title>
    <url>%2Fyzhiwei.github.io%2F2019%2F07%2F22%2F%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[上下标，分数和根号下标_ X_21$$X_2$$ 上标^ X^21$$X^2$$ 混合使用 x^2_51$$x^2_5$$ 分数frac \frac{3}{5}1$$\frac&#123;3&#125;&#123;5&#125;$$ 根号 sqrt \sqrt[4]{5}1$$\sqrt[4]&#123;5&#125;$$ 常用的运算符加减\pm {x}\pm{y}1$$&#123;x&#125;\pm&#123;y&#125;$$ 乘 \times {x}\times{y}1$$&#123;x&#125;\times&#123;y&#125;$$ 除 \div {x}\div{y}1$$&#123;x&#125;\div&#123;y&#125;$$ 点乘 \cdot {x}\cdot{y}1$$&#123;x&#125;\cdot&#123;y&#125;$$ 大于等于 \geq {x}\geq{y}1$$&#123;x&#125;\geq&#123;y&#125;$$ 小于等于 \leq {x}\leq{y}1$$&#123;x&#125;\leq&#123;y&#125;$$ 不等于 \neq {x}\neq{y}1$$&#123;x&#125;\neq&#123;y&#125;$$ 约等于 \approx {x}\approx{y}1$$&#123;x&#125;\approx&#123;y&#125;$$ 恒等于 \equiv {x}\equiv{y}1$$&#123;x&#125;\equiv&#123;y&#125;$$ 累加 \sum \sum_{i=0}^{n}{(x_i+y_i)}1$$\sum_&#123;i=0&#125;^&#123;n&#125;&#123;(x_i+y_i)&#125;$$ 累乘 \prod \prod_{i=1}^{n}{x_i}1$$\prod_&#123;i=1&#125;^&#123;n&#125;&#123;x_i&#125;$$ 求极限 \lim \lim_{x\to0}{x}1$$\lim_&#123;x\to0&#125;&#123;x&#125;$$ 求积分 \int \int_{a}^{b}{f(x)}1$$\int_&#123;a&#125;^&#123;b&#125;&#123;f(x)&#125;$$ 矩阵与行列式矩阵 \begin{matrix} 1&&2&&3\\ 4&&5&&6 \end{matrix}1234$$\begin&#123;matrix&#125;1&amp;&amp;2&amp;&amp;3\\4&amp;&amp;5&amp;&amp;6\end&#123;matrix&#125;$$ \begin{bmatrix} 1&&2&&3\\ 4&&5&&6 \end{bmatrix}1234$$\begin&#123;bmatrix&#125;1&amp;&amp;2&amp;&amp;3\\4&amp;&amp;5&amp;&amp;6\end&#123;bmatrix&#125;$$ 行列式 \begin{vmatrix} 1&&2&&3\\ 4&&5&&6 \end{vmatrix}1234$$\begin&#123;bmatrix&#125;1&amp;&amp;2&amp;&amp;3\\4&amp;&amp;5&amp;&amp;6\end&#123;bmatrix&#125;$$]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写于生日当天]]></title>
    <url>%2Fyzhiwei.github.io%2F2019%2F07%2F20%2F%E5%86%99%E4%BA%8E21%E5%B2%81%E7%94%9F%E6%97%A5%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客多校第一场]]></title>
    <url>%2Fyzhiwei.github.io%2F2019%2F07%2F18%2F%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[题目链接： https://ac.nowcoder.com/acm/contest/881#question A题目 思路这道题要求两个数组中最小值的下标相等，求最大值p可以使用单调栈来维护，分别维护序号和值 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define maxn 100005int a[maxn],b[maxn]; //记录初始两个数组int l1[maxn],l2[maxn]; //记录最小数的idstruct node&#123; int id; int val;&#125;s[maxn];int n;void solve(int *c,int *l)&#123; int top=0; s[0]=&#123;0,0&#125;; for(int i=0;i&lt;=n;i++)&#123; while(top&amp;&amp;s[top].val&gt;c[i]) top--; l[i]=s[top].id; s[++top]=node&#123;i,c[i]&#125;; &#125;&#125;int main(int argc, char const *argv[])&#123; while(cin&gt;&gt;n) &#123; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++) cin&gt;&gt;b[i]; int ans=n; solve(a,l1); solve(b,l2); for(int i=1;i&lt;=n;i++) &#123; if(l1[i]!=l2[i])&#123; ans=i-1; break; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; BCDE题目 思路一开始这个题想偏了，原来是AB中可以插入BA，BA中可以插入AB。看了部分博客，大部分都是用dp做的，状态转移方程都写的不太一样但总体都遵循这样的原则假设有i个A，j个B那么num(AB）=num(A)-num(B) num(BA) =num(B)-num(A)所以{i-j}\leq{n} {j-i}\leq{m}状态转移方程 dp[i][j]+=dp[i][j-1]; dp[i][j]+=dp[i-1][j]; 代码123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=1e9+7;const int maxn=2e3+5;ll dp[maxn][maxn];int main(int argc, char const *argv[])&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m)&#123; for(int i=0;i&lt;=n+m;i++)&#123; for(int j=0;j&lt;=n+m;j++)&#123; dp[i][j]=0; &#125; &#125; dp[0][0]=1; for(int i=0;i&lt;=n+m;i++)&#123; for(int j=0;j&lt;=n+m;j++)&#123; if(i-j&lt;n)&#123; dp[i+1][j]=(dp[i+1][j]+dp[i][j])%mod; &#125; if(j-i&lt;m)&#123; dp[i][j+1]=(dp[i][j+1]+dp[i][j])%mod; &#125; &#125; &#125; cout&lt;&lt;dp[n+m][n+m]&lt;&lt;endl; &#125; return 0;&#125; F代码123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(int argc, char const *argv[])&#123; ll x1,y1,x2,y2,x3,y3; while(cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3)&#123; ll s=11/2*abs(x1*y2 + x2*y3 + x3*y1 - x1*y3 - x2*y1 - x3*y2); cout&lt;&lt;s&lt;&lt;endl; &#125; return 0;&#125; GHIj题目 思路先比较整数部分，然后比较小数部分，小数部分采用取模的方式表示，比较的时候采用交叉相乘的方式。 代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main(int argc, char const *argv[])&#123; ll x,a,y,b; while(cin&gt;&gt;x&gt;&gt;a&gt;&gt;y&gt;&gt;b) &#123; if(x/a&gt;y/b)&#123; cout&lt;&lt;"&gt;"&lt;&lt;endl; &#125;else if(x/a&lt;y/b)&#123; cout&lt;&lt;"&lt;"&lt;&lt;endl; &#125;else&#123; if((x%a)*b&gt;(y%b)*a)&#123; cout&lt;&lt;"&gt;"&lt;&lt;endl; &#125;else if((x%a)*b&lt;(y%b)*a)&#123; cout&lt;&lt;"&lt;"&lt;&lt;endl; &#125;else if((x%a)*b==(y%b)*a)&#123; cout&lt;&lt;"="&lt;&lt;endl; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>多校</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理复习]]></title>
    <url>%2Fyzhiwei.github.io%2F2019%2F07%2F06%2F%E8%AE%A1%E7%BB%84%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[计算机系统概论计算机的性能指标吞吐量 一台计算机在某一时间间隔内能够处理的信息量 响应时间 从输入有效到系统产生响应之间的时间度量 利用率 在给定的时间间隔内系统被实际使用的时间所占的比率。用百分比来表示 处理机字长 指处理机运算器中一次能够完成二进制数运算的位数 总线宽度 cpu运算器与存储器之间进行互连的内部总线二进制位数 存储器容量 存储器中所有存储单元的总数目。通常用KB，MB表示 存储器带宽 单位时间内从存储器读出的二进制数信息量 主频/时钟周期 主时钟的频率教cpu的主频 cpu执行时间 表示CPU执行一般程序占用的CPU时间 CPU执行时间=CPU时钟周期数 CPU时钟周期 CPI 每条指令周期数 硬件组成要素运算器 进行算术运算和逻辑运算 控制器 控制计算机各部件有条不紊的工作 存储器 储存0，1代码 输入设备与输出设备 多级组成的计算机系统微程序设计级 直接由硬件执行 一般机器级 微程序 操作系统级 操作系统 汇编语言级 汇编程序 高级语言级 编译程序 运算方法和运算器流水线多层次的存储器存储器的分级Why 在一个存储器中同时兼顾容量大，速度快，成本低是困难的。 高速缓存存储器（cache） 高速存取指令和数据，存取速度快，但存储容量小 主存储器 存放计算机运行期间的大量程序和数据。和cache能交换数据和指令。 外存储器 大容量辅助存储器 存储容量大，位成本低，通常用来存放系统程序和大型数据文件及数据库 主存储器的性能指标字存储单元 存放一个机器字的存储单元。 相应的单元地址叫字地址。 字节存储单元 存放一个字节的单元 ，相应的地址为字节地址， 存储容量 一个存储器中可以容纳的存储单元总数。一个字节为8个2进制位 存储时间 存储器访问时间，指一次读操作命令发出到该操作完成，将数据读出到数据总线上所经历的时间。 存储周期 指连续启动两次读操作所需间隔的最小时间。 存储器带宽 单位时间内存储器所存取的信息量。 存储器容量的扩充1.字长位数扩展 2.字存储容量扩展 多模块交叉存储器地址在模块中安排方式有两种：顺序方式，交叉方式。 在顺序方式中，某个模块进行存取时，其他模块不工作。当某一模块出现故障时，其他模块可以照常工作。缺点就是各模块一个接一个串行工作，因此存储器的带宽受到了限制。 交叉方式的存储器可以实现多模块流水式并行存取，大大提高存储器的带宽 cache基本原理解决cpu与主存之间速度不匹配 三个计算 1.命中率h=Nc/(Nc+Nm) 2.平均访问时间Ta=hTc+（1-h)Tm 3.访问效率e=1/(r+(1-r)h)r=Tm/Tc 主存与cache的地址映射主存块大小与cache行大小相同 直接映射方式 内存地址格式 标记 行 字地址 全相联映射 内存地址格式 标记 字地址 组相联映射 内存地址格式 标记 组号 字地址 替换策略最不经常使用（LFU）算法设置计时器，从0开始技术，每访问一次，被访问的计数器增1，将一段时间内被访问次数最少的那行数据换出。 不能严格反映近期访问情况。 近期最少使用（LRU）算法将近期内长久未被访问的行换出 Cache每命中一次，命中行计数器清0，其他各行计数器增1，当需要替换时，将计数器最大的行换出。 使cache有较高的命中率 随机替换从特定的行位置中随机的选取一行换出即可。 优点：在硬件上容易实现，且速度也比前两种快。 缺点：随意换出的数据很可能很快就被使用，从而降低命中率和cache工作效率 指令系统指令格式指令字用二进制代码表示的结构形式。由操作码字段和地址码字段组成。 操作码OP字段表征指令的操作特性与功能。地址码A字段通常指定参与操作数的地址。 操作码组成操作码字段的位数一般取决与计算机指令系统的规模。 地址码根据一个指令中有几个操作数地址，可将该指令称为几操作数指令或几地址指令。 二地址指令格式中存储器-存储器（SS）型指令 访问内存的指令格式。操作时都是涉及内存单元。寄存器-寄存器（RR）型指令 访问寄存器的指令格式。寄存器-存储器（RS）型指令 既要访问内存单元，又要访问寄存器。 指令字长度一个指令字中包含二进制代码的位数。分为单字长指令，半字长指令，双字长指令 分析指令格式的特点 什么字长什么地址指令 （单字长二地址指令） 操作码字段op可以指定的指令数 分析指令 指令和数据的寻址方式指令的寻址方式顺序寻址方式程序依次执行的过程 跳跃寻址方式当程序转移执行的顺序时，采用跳跃寻址方式。所谓跳跃，是指下条指令的地址码不是由程序计数器给出，而是由本条指令给出。 操作数的寻址方式形成操作数的有效方法，称为操作数的寻址方式隐含寻址不是明显的给出操作数的地址，而是在指令中隐含着操作数的地址 立即寻址指令的地址阶段不是操作数的地址，而是操作数本身 直接寻址在指令格式的地址字段中直接指出操作数在内存中的地址A 间接寻址形式地址A不是操作数A的真正地址，而是操作数地址的指示器 寄存器寻址 当操作数不在内存中，而是放在cpu的通用寄存器中时，可采用寄存器寻址方式 寄存器间接寻址指令格式中的寄存器内容不是操作数，而是操作数的地址 偏移寻址 直接寻址和寄存器间接寻址方式的结合EA=A+（R）相对寻址基址寻址变址寻址 段寻址方式 堆栈寻址寄存器堆栈和存储器堆栈 中央处理器cpu的功能指令控制 程序的顺序控制 操作控制 控制部件按指令的要求进行工作 时间控制 对各种操作实施时间上的定时 数据加工 对数据进行算术运算和逻辑运算处理 cpu中的主要寄存器数据缓冲寄存器（DR）暂时存放ALU的运算结果 指令寄存器（IR）用来保存当前正在执行的一条指令 程序计数器（PC）确定下一条指令的地址 数据地址寄存器（AR）保存当前cpu所访问的数据cache存储器中单元的地址 通用寄存器（R0-R3）当算术逻辑单元（ALU）执行算术或逻辑运算时，为ALU提供一个工作区。 状态字寄存器（psw）保存由算术指令和逻辑指令运算或测试结果建立的各种代码。 微程序控制器 优点具有规整性，灵活性，可维护性等优点。 基本思想仿照通常的解题程序的方法，把操作控制信号编成所谓的微指令，存放到一个只读存储器里，当机器运行时，一条又一条的读出这些微指令，从而产生全机所需要的各种操作控制信号，使相应部件执行所规定的动作。 微命令 控制部件通过控制线向执行部件发出各种控制命令。微操作 执行部件接受微命令后所进行的操作 控制存储器 控制存储器用来存放全部指令系统的微程序，是一种只读型存储器。 微指令寄存器存放由控制存储器读出的一条微指令信息。决定将要访问的下一条微指令的地址 流水CPU并行处理技术时间并行空间并行时间并行+空间并行 流水线的结构时空图非流水线时空图流水线时空图 流水线分类指令流水线算数流水线处理机流水线 宏流水线，是指程序步骤的并行。 主要问题资源相关多条指令进入流水线后在同一机器时钟周期内争用同一个功能部件所发生的冲突 数据相关先写后读（RAW）对应真数据相关时的情况，下一条指令依赖于上一条指令的执行结果，必须先将结果写入之后再由下一条指令来读。如果先读的话读到的是旧值，不是运算的正确输入。 先写后写（WAW）这个对应于输出相关，比如最后将要输出的值为后一条指令的执行结果，可是这条指令却先执行并写入了，之后执行了上一条指令的写入操作，对应于输出的结果而言就出现冲突了。 先读后写（WAR）这个对应于名相关，指令在读取某一数据之前其读取的对象先被相关的指令写入了运算结果，这导致了读取的数据不是原来的数据，而是下一条指令运行的结果 控制相关延迟转移法转移预测法 总线系统总线的概念构成计算机系统的互联结构，是多个系统功能部件进行数据传送的公共同路，借助与总线连接，计算机在个系统功能部件之间实现地址，数据和控制信息的交换，并在征用资源的基础上进行工作。 总线分为3类内部总线cpu内部连接各寄存器及运算部件之间的总线。 系统总线 cpu同计算机系统的其他高速功能部件，如存储器，通道等相互连接的总线。 I/O总线低速I/O设备之间相互连接的总线。 总线接口信息传送方式串行传送 按顺序来传送表示一个数码的所有二进制位的脉冲信号，每次一位。并行传送 对每个数据位都需要单独一条传输线。信息有多少二进制位组成，就需要多少传输线，从而使得二进制位数在不同的线上同时进行传输。分时传送。1 总线复用方式 某个传输线上既传送地址信息，又传送数据信息。2 共享总线的部分分时使用总线。 接口模块的功能控制靠指令信息来控制外围设备的动作 缓冲在外围设备和计算机系统其他部件之间用作一个缓冲器，以补偿各种设备在速度上的差异。 状态监视外围设备的工作状态并保存状态信息 转换可以完成任何要求的数据转换 整理可以完成一些特别的功能，在需要时修改字计数器或当前内存地址寄存器 程序中断每当外围设备向cpu请求某种动作时，接口模块即发生一个中断请求信号到cpu 总线的总裁为了解决多个主设备同时竞争总线控制权的问题，必须具有总线仲裁部件。一般采用优先级或公平策略进行仲裁。 集中式仲裁每个功能模块有两条线连到总线控制器：一条是送往仲裁器的总线请求信号线BR，一条是仲裁器送出的总线授权信号线BG 链式查询方式总线授权信号BG串行的从一个I/O接口传送到下一个I/O接口。假如BG到达的接口无总线请求，则继续向下查询，假如BG到达的接口有总线请求，BG信号便不再向下查询。 特点 在查询链中离总线仲裁器最近的设备具有最高优先级。 优点： 只用很少几根线就能按一定优先次序实现总线仲裁，并且这种链式结构很容易扩充设备 缺点 对询问链的电路很敏感，如果第i个设备的接口中有关链的电路有故障，那么第i个以后的设备都不能正常工作。查询链的优先级是固定的，如果优先级高的设备出现频繁的请求时，那么优先级低的设备将长期不能使用总线。 计时器定时查询方式总线上任一设备要求使用总线时，通过BR线发出总线请求，总线仲裁器在接收到信号以后，在BS线为0的情况下让计数器开始计数，计数值通过一组地址线发现该设备。每个设备接口都有一个设备地址判别电路，当地址线上的计数值与请求总线的设备地址相一致时，该设备置1BS线，获得了总线使用权，此时中止计数查询 优点 可以由计数器的初值方便的改变优先次序。 独立请求方式每一个共享总线的设备均有一对总线请求线BR和总线授权线BG，当设备要求使用总线时，便发出该设备的总线信号。总线仲裁器有一个排队电路，根据一定的优先次序决定优先相应哪一个设备，给设备已授权信号BG 优点：相应速度快，对优先次序的控制相当灵活。他可以预先固定优先级，也可以通过程序来改变优先次序，还可以用屏蔽某个请求的方法，不响应来自无效设备的请求。 分布式仲裁不需要集中的总线仲裁器，每个潜在的主方功能模块都有自己的仲裁号和仲裁器。当他们有总线请求时，把他们唯一的仲裁号发送到共享的仲裁总线上，每个仲裁器将仲裁总线上的号与自己做比较，如果仲裁总线上的号大，则他的总线请求不予响应，并撤销他的仲裁号。最后，获胜者的仲裁号保留在仲裁总线上。分布式仲裁是以优先级仲裁策略为基础。 外存与IO设备磁盘存储设备磁盘上信息的分布盘面的上下两面都能记录信息，通常把磁盘片表面称为记录面。记录面上一系列同心圆称为磁道 磁道和扇区的排列称为格式。 编号：磁道的编址是从外向内依次编号，最外一个同心圆叫0磁道，最里面的一个同心圆叫n磁道，n磁道里面的圆面积并不用来记录信息。 扇区的编号有多种方法，可以连续编号，也可以间隔编号。 可用n磁道m扇区的磁盘地址找到实际磁盘上与之相对应的记录区。 对活动头磁盘组来说，磁盘地址是由记录面号（磁头号），磁道号和扇区号三部分组成。 在磁道中，信息是按区存放的，每个区中存放一定数量的字或字节，每个区存放字或字节数是相同的。 磁盘存储器的每个扇区记录定长的数据，因此读/写操作是以扇区为单位一位一位串行进行的。 每个记录块由头部空白段，序标段，数据段，校验字段以及尾部空白段组成。空白段用来留出一定时间作为磁盘控制器的读写准备时间，序标被用来作为磁盘控制器的同步定时信号。数据段为本扇区所记录的数据。校验字段用来检验磁盘读出的数据是否正确。 磁盘存储器的技术指标存储密度：存储密度分为道密度，位密度和面密度。道密度：沿磁盘半径方向单位长度的磁道数： 单位：道/英寸位密度 磁道单位长度上能记录的二进制位数 单位 位/英寸面密度 道密度和位密度的乘积 存储容量 一个磁盘存储器所能存储的字节总数，称为磁盘存储器的存储容量。分为格式化容量和非格式化容量，格式化容量：按照某种特定的记录格式所能存储的信息总量，是用户可以真正使用的容量。非格式化容量：磁记录表面可以利用的磁化单元总数。 平均存取时间 是指从发出读写命令后，磁头从某一起始位置移动到新的记录位置，到开始从磁盘表面读出或写入信息加上传送数据所需要的时间。 1.将磁头定位到所要求的磁道上所需要的时间称为找道时间 （最大找道时间与最小找道时间的平均值，目前平均找道时间为12ms）2.找道完成后至磁道上需要访问的信息到达磁头上的时间称为等待时间 （磁盘旋转一周所需时间的一半）3.数据传送时间 计算 平均存取时间Ta=Ts（找道时间）+1/2r（等待时间）+b/rn（数据传送时间）r 转速b 传送的字节数 数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数。Dr=nN(字节/秒)n 磁盘旋转速度N 每磁道字节数 输入输出系统 外围设备的速度分级与信息交换方式外围设备的速度分级速度极慢或简单的外围设备如机械开关，显示二极管等。Cpu只要接收或发送数据就可以了。 慢速或中速的外围设备异步定时方式 高速的外围设备同步定时方式 信息交换方式程序查询方式最简单的输入输出方式，数据在cpu和外围设备之间传送完全靠计算机程序控制 优点：cpu的操作与外围设备的操作能够同步，硬件结构比较简单。缺点：外围设备动作很慢，程序进入查询循环时将白白浪费掉cpu很多时间。 程序中断方式中断是外围设备主动告诉cpu，准备送出输入数据或接收输出数据的一种方法。当一个中断发生后，cpu暂停他的现行程序，而转向中断处理程序，从而可以输入或输出一个数据。 优点：节约了cpu的时间，是管理I/O操作的一个比较有有效的操作方法。 直接内存访问模式(DMA)由硬件执行I/O交换的工作方式。这种方式及考虑到中断响应，同时又要节约中断开销。DMA控制器从cpu完全接管对总线的控制，数据交换完全不经过cpu，而直接在内存和外围设备之间进行。 优点：数据传送速度很高，传送速率仅受到内存访问时间的限制。缺点：与中断方式相比，需要更多的硬件。 使用场合：内存与高速外围设备之间大批数据交换的场合。 通道方式Cpu将部分权力下放给通道，通道是一个具有特殊功能的处理器。可以实现对外围设备的统一管理和外围设备与内存之间的数据传送。 优点：大大提高效率缺点：花费更多硬件为代价 主要由程序实现：程序查询方式，查询中断方式主要由硬件实现：DMA，通道 程序中断方式中断的概念在程序中断方式中，某一外设的数据准备就绪后，它主动向cpu发送信号，请求cpu暂时中断目前正在执行的程序而进行数据交换。 多级中断多级中断系统是指计算机系统中有相当多的中断源，根据各中断事件的轻重缓急程度不同而分成若干级别，每一中断级分配给一个优先权。 一般在某一级中断被响应后，要置“1”（关闭）本级和优先权低于本级的中断屏蔽发生器，置“0”（开放）更高级的中断屏蔽触发器，以此来实现正常的中断嵌套。具体题参考例2 中断控制器中断优先级选择方式 完全嵌套方式一种固定优先级的方式，连至IR0的设备优先级最高，IR7优先级最低 轮换优先级方式A每个级别的中断保证都能够被处理，将给定的中断级别处理完后，立刻将它放在最低级别的位置中。 轮换优先级方式B要求CPU可在任何时间规定最优优先级，然后顺序的规定其他IR线上的优先级。 查询方式由cpu访问8259的中断状态寄存器，一个状态字能够表示出正在请求的最高优先级IR线。 两种屏蔽方式 简单屏蔽方式提供8位屏蔽字，每位对应着各自的IR线。被置位的任一位则禁止了对应IR线上的中断。 特殊屏蔽方式允许cpu让来自低优先级的外设中断请求去中断高优先级的服务程序。 DMA方式是一种完全由硬件执行I/O交换的工作方式。 DMA控制器从cpu完全接管对总线的控制。 优点：速度快 DMA传送方式停止CPU访内周期挪用DMA与cpu交替访内]]></content>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络复习]]></title>
    <url>%2Fyzhiwei.github.io%2F2019%2F07%2F06%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[运输层tcp三次握手 建立一个tcp连接时，需要客户端和服务端总发送三个包已确定连接的确定 为什么需要3次握手 Tcp是面对连接的，所以需要双方都确认连接的建立 第一次握手 客户端请求建立连接，发送SYN报文段： 标志位置1 选择初始序列号 第二次握手 服务端应答客户端，并请求建立连接 回应一个SYNACK报文段 选择初始序列号告知客户端 为服务器分配缓存 第三次握手 客户端争对服务器端请求确认应答 回应一个ACK 可以包含数据 rdt(停等协议)什么是可靠不错，不丢，不乱 基本接口 rdt 1.0不会发生错误不会丢弃分组 rdt 2.0可能发生位错误 利用校验和检测位错误 如何从错误中恢复确认机制（ACK）：接收方显示的告知发送方分组已正确接收NAK：接收方显式的告诉发送方分组有错误发送方收到NAK后，重传分组 rdt2.0引入的新机制差错检测接收方反馈控制信息：ACK/NAK重传 缺陷ACK/NAK可能会发送错误 rdt2.1为ACK,NAK增加校验和，检错并纠错 如果ACK/NAK坏掉，发送方重传不能简单的重传，产生重复分组 如何解决重复分组问题？序列号：发送方给每个分组增加序列号接收方丢弃重复分组 rdt 2.2无NAK消息协议 与rdt2.1功能相同，但是只使用ACK如何实现？接收方通过ACK告知最后一个被正确接收的分组在ACK消息中显式的加入被加入的确认号 发送方在收到重复ACK之后，采用与收到NAK消息相同的作用重传当前分组 rdt 3.0信道可能发生错误，也可能丢失分组 方法：发送方等待合理时间如果没收到ACK，重传如果分组或者ACK只是延迟而不是丢了重传会产生重复，序列号机制能够处理接收方须在ACK中显式的告知所确认的分组 需要计时器 rdt用到的技术rdt 1.0 rdt 2.0 校验和 确认机制 rdt 2.1 校验和 确认机制 序列号 rdt 2.2 校验和 ACK 序列号 rdt 3.0 计时器 滑动窗口协议允许发送方在收到ACK之前就连续发送多个分组 更大的序列号范围 发送方和/或接收方需要更大的存储空间来缓存分组窗口 允许使用的序列号范围 窗口长度为n：最多有n个等待确认的信息 回退N步GBN（累计确认机制）发送方：头部分组包含K-bit序列号窗口尺寸为n，最多允许n个分组为确认ACK（n）确认到序列号n（包含n）的分组都已被正确接收可能收到重复ACK为空中的分组设置计时器超时时间：重传序列号大于等于n，还未收到ACK的所有分组 接收方ACK机制：发送拥有最高序列号的，已被正确接收的分组的ACK 可能产生重复ACK 只需要记住唯一的expectedseqnum乱序到达的分组 直接丢弃-接收方没有缓存 重新确认序列号最大的，按需到达的分组 SR接收方对每一个分组进行单独确认 设置缓存机制，缓存乱序到达的分组发送方只重传那些没收到ACK的分组 为每一个分组设置定时器发送方窗口 N个连续的序列号 限制已发送且为确认的分组 发送方尺寸+接收方尺寸&lt;=2K 流量控制当recwindow=0，选择发送一个很小的段，重新接收新的recwindow，避免死锁的情况 拥塞控制定义太多发送主机发送了太多数据或者发送速度太快以至于网络无法处理 表现分组丢失(路由器缓存溢出)分组延迟过大(在路由器缓存中排队) 控制基本原理 sender限制发送速率动态调整以改变发送速率反映所感知到的拥塞控制 如何感知网络拥塞Loss事件=timeout或3个重复ACK发生loss事件后，发送方降低速率 如何合理的调整发送速率加性增-乘性减：AIMD慢启动：SS 加性增-乘性减逐渐增加发送速率，谨慎探测可用带宽，直至发生loss加性增：每个RTT将CongWin增大一个MSS-拥塞避免乘性减：发生Loss后将CongWin减半 慢启动TCP建立连接时可用带宽可能远远高于初始速率希望快速增长 原理当连接开始时，指数性增长 流量控制与拥塞控制区别流量控制：是一种端对端的，仅与特定的发送方和接收方有关 拥塞控制：确保子网可以承载所到达的流量，是一个全局性问题。 网络层ip关于ipipv4 32bit ipv6 128bit子网掩码：不能单独存在，必须结合ip地址一起使用作用，将某个ip地址划分为网络地址和主机地址两部分。通过ip地址，可以判断出两个ip是不是在同一个局域网内部子网掩码可以看出有多少位是网络号，有多少位是主机号 ip地址与子网掩码做&amp;运算得到网络地址 192.168.2.1/24表示前24位不变，后8位全0变化到全1的过程全0是子网网络地址，全1是子网广播地址，这两个地址是不分配给主机使用的。表示范围 192.168.2.1-192.168.2.254 数据报格式 TCP 6UDP 17 数据报分片长度 标识 标记 偏移字段4000 x 1 01500 x 1 01500 x 1 1851040 x 0 370（20个字节ip首部） 直接交付与间接交付直接交付：不经过路由器的报文传输 间接交付：需要路由器的转发交付 分组的转发 目的网络地址H2 128.30.33.128 1.H1检查是否连在本网络上本子网的子网掩码 网络层路由选择算法链路状态路由选择算法Dijkstra算法所有节点掌握网络拓扑和链路费用通过链路状态广播所有节点拥有相同信息计算从一个节点到其他节点的最短路径 距离向量路由选择算法Bellman-ford算法（动态规划）dx(Y): 从x到y的最小距离dx(Y)=min(c(x,v)+dv(Y)) 不需要知道整个网络的拓扑结构重点：节点获得最短路径的下一跳，该信息用于转发表中结点x： 已知到达每个邻居的费用：c(x,y) 维护其所有邻居的距离向量Dv=【Dv（y）】核心思想：每个节点不定时的将其自身的DV估计发送给其邻居当x接收到邻居新的DV估计时，及依据B-F更新其自身的距离向量 毒性逆转思想 如果z通过y路由选择到目的地x，则z将通告y，到他到x的距离是无穷大。 协议rip协议距离向量路由算法距离度量：跳步数，每条链路一个跳步每隔30s，邻居之间交换一次DV，成为公告每次通告，最多25个目的子网 rip 链路失效，恢复如果180s没有收到通告-邻居，链路失效经过该邻居的路由不可用 重新计算路由向邻居发送新的通告邻居在依次向外发送通告（如果转发表改变） OSPF协议“开放”：公众可用采用链路状态路由算法LS分组扩散每个路由器构造完整的网络拓扑图利用Dijkstra算法计算路由 OSPF通告中每个入口对应一个邻居 链路层随机接入协议时隙ALOHA当节点有一个新帧要发送时，他等待下一个时隙开始并在该时隙传输整个帧如果没有碰撞，该节点成功的传输他的帧，不需要考虑重传如果有碰撞，该节点在时隙结束之前检测到这次碰撞，该节点已概率p在后续的每个时隙中重传他的帧，直到该帧被无碰撞的传输出去 ALOHA 非时隙，完全分散的协议 当一帧首次到达，节点立刻将该帧完整的传输到广播信道，如果一个传输的帧与多个传输经历了碰撞，这个节点将立即已概率p重传该帧，否则，该节点等待一个帧传输时间。在此等待过后，他则以概率p传输该帧，否则以概率1-p在另一个帧时间等待。 CSMA载波监听：发送帧之前，监听信道（载波）信道空闲：发送完整帧信道忙： 推迟发送1- 坚持CSMA非坚持CSMAP- 坚持CSMA CSMA/CD短时间内检测冲突冲突后传输中止，减少信道浪费冲突检测：有线局域网容易实现，测量信号强度，比较发射信号与接收信号无线局域网很难实现，接收信号强度淹没在本地发射信号强度下 边发边听，不发不听当Lan中2个节点的最大传播延迟趋近于0或最长帧传输延迟趋近于∞时，效率趋近于1 交换机任务接收入链路层帧并将他们转发到出链路 交换机转发与过滤过滤 决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能 转发 决定一个帧应当被转发到哪一个接口，并把该帧移动到那些接口的交换机功能 交换机的转发和过滤借助与交换机表 自学习交换机是自学习的 交换机表是通过自学习得到的 附录名词解释http HyperText Transfer Protocol 超文本传输协议 英特网上应用最为广泛的一种网络传输协议 Dns Domain Name System 域名系统 一个由分层的dns服务器实现的分布式数据库，一个使地主机能够查询分布式数据库的应用层协议 Smtp Simple Mail Transfer Protocol 简单邮件传输协议 一个相对简单的基于文本的协议 ftp File transfer protocol 文件传输协议 用在网络上进行文件传输的一套标准协议 pop3 post office protocol-version 3 邮件协议版本3 主要用于支持使用客户端远程管理在服务器上的电子邮件 Tcp Transfer control protocol 传输控制协议 面向连接的，可靠的，基于字节流的传输层通信协议 Rdt reliable data transfer protocol 可靠数据传输协议 为了保证数据传输的可靠性而在传输层采用的协议 Gbn go-back N 回退N步 允许发送方发送多个分组而不需等待确认，但也受限与流水线中未确认的分组数不能超过某个最大允许数N的一个协议 Sr Selective Repeat 选择重传 让发送方仅重传那些他怀疑在接收方出错的分组而避免了不必要的重传 icmp Internet control message protocol Internet控制报文协议 用于在IP主机，路由器之间传递控制消息的协议 Rip Routing Information protocol 路由信息协议 是一种动态路由选择协议，用于自治系统（AS）内的路由信息的传递 Ospf Open shortest Path First 开放式最短路径优先 是一个内部网关协议，用于在单一自治系统内决定路由。 csma/cd Carrier Sense Multiple Access/collision Detection 带碰撞检测的载波监听多路访问技术 关于协议应用层DNS FTP HTTP POP3 SMTP 传输层TCP UDP 网络层IP ICMP OSPF BGP IS 链路层以太网]]></content>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bfs]]></title>
    <url>%2Fyzhiwei.github.io%2F2019%2F04%2F21%2Fbfs%2F</url>
    <content type="text"><![CDATA[广度优先搜索实现的思想对于bfs，我们需要的就是按层次依次遍历，需要采用队列这一个数据结构，当然，我们也可以采用模拟队列的方式来操作，我们首先要做的就是将起始点的“朋友”加入队列，然后在加入“朋友”的“朋友” 代码123456789101112131415161718192021222324queue&lt;int&gt; q; //队列的建立int start, ed //起始点和终止点int bfs()&#123; q.push(start); 先将start入队 q cur,next; //next为cur的下一个元素 while(q.size()) &#123; cur=q.front(); q.pop(); for(int i=0;i&lt;n;i++) &#123; next=cur+ ; if( ) &#123; if(到达终点) &#123; &#125; q.push(next); &#125; &#125; &#125;&#125; 12while(!q.empty())q.pop(); 对于有些题目，必须要清空队列，但有些不清空队列也能ac，奇怪。 应用bfs一般是用来求最短路径的，我们一般都会申请一个数组，来记录到达其中一点的最短路径 有时我们需要输出路径，这时候我们需要新建一个数组，来储存它上一个节点的信息 一个完整题的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;#define maxn 31char a[maxn][maxn][maxn];int d[maxn][maxn][maxn];int dir[6][3]=&#123;&#123;-1,0,0&#125;,&#123;1,0,0&#125;,&#123;0,1,0&#125;,&#123;0,-1,0&#125;,&#123;0,0,1&#125;,&#123;0,0,-1&#125;&#125;;//2向右3向左4向上int L,R,C;struct node&#123;int x,y,z;&#125;;node start,ed;int bfs()&#123; queue&lt;node&gt; Q; Q.push(start); node cur; node next; while(Q.size()) &#123; cur=Q.front(); Q.pop(); for(int i=0;i&lt;6;i++) &#123; next.x=cur.x+dir[i][0]; next.y=cur.y+dir[i][1]; next.z=cur.z+dir[i][2]; if(next.x&gt;=0&amp;&amp;next.x&lt;R&amp;&amp;next.y&gt;=0&amp;&amp;next.y&lt;C&amp;&amp;next.z&gt;=0&amp;&amp;next.z&lt;L&amp;&amp;a[next.z][next.x][next.y]!='#'&amp;&amp;d[next.z][next.x][next.y]==0) &#123; //a[cur.z][cur.x][cur.y]='#'; 这样操作的话在栈中的点，也有可能到达当前的next点， //若用d[next.z][next.x][next.y]==0判断，只要到达next，就不会再判断 d[next.z][next.x][next.y]=d[cur.z][cur.x][cur.y]+1; if(next.x==ed.x&amp;&amp;next.y==ed.y&amp;&amp;next.z==ed.z) return d[ed.z][ed.x][ed.y]; Q.push(next); &#125; &#125; &#125; return -1;&#125;int main()&#123; while(cin&gt;&gt;L&gt;&gt;R&gt;&gt;C&amp;&amp;(L+R+C)!=0) &#123; sum=0; memset(d,0,sizeof(d)); for(int i=0;i&lt;L;i++) for(int j=0;j&lt;R;j++) for(int k=0;k&lt;C;k++) &#123; cin&gt;&gt;a[i][j][k]; if(a[i][j][k]=='S') &#123; start.z=i;start.x=j;start.y=k; &#125; else if(a[i][j][k]=='E') &#123; ed.z=i;ed.x=j;ed.y=k; &#125; &#125; // cout&lt;&lt;start.x&lt;&lt; " "&lt;&lt;start.y&lt;&lt;" "&lt;&lt;start.z&lt;&lt;endl; // cout&lt;&lt;ed.x&lt;&lt;" "&lt;&lt;ed.y&lt;&lt;" "&lt;&lt;ed.z&lt;&lt;endl; if( bfs()==-1) printf("Trapped!\n"); else printf("Escaped in %d minute(s).\n",d[ed.z][ed.x][ed.y]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树（kruskal）]]></title>
    <url>%2Fyzhiwei.github.io%2F2019%2F03%2F06%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88kruskal%EF%BC%89%2F</url>
    <content type="text"><![CDATA[算法原理kruskal是先选确定边最小的一条边，然后依次确定各条边，要确保生成的最小生成树不闭合。 采用并查集实现算法。 模块定义边1234struct bian&#123; int start,end,power;&#125;node[5050]; //每条边的定义 按照权值大小排序1234int cmp(bian a,bian b)&#123; return a.power&lt;b.power;&#125; 查找的部分这一部分有必要解释一些原理,我们需要查找的是每一个点的“上级”，即通过它我们最多可以到什么地方，举个例子，如果a能到b，b能到c，那么a也能够到达c点，这时，我们就可以定义c为a，b的上级，我们需要的就是找到每一个点的上级。 我们先假设每一个点的上级为它本身1234int father[5000];for(int i=1;i&lt;5000;i++)&#123; father[i]=i;&#125; 查找123int find(int x)&#123; return father[x]==x?x,find(father[x]);&#125; 查找了每一个上级，此时会有若干个分枝，现在需要做到的就是将若干个分支给合并，此时我们先判断两个点他们的上级是否相同，若不同，这将他们的一个上级变为另外一个上级的下级，这样，这两点便能够连在一起。 合并123456789int combine(int x,int y)&#123; int fx=find(x); int fy=find(y); if(fx!=fy) //两个点上级不一样 &#123; father[fx]=fy; &#125;&#125; 完整的一个代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;int father[5050],a[5050],b[5050];int sum;struct bian&#123; int start,end,power;&#125;node[5050];int cmp(node a,node b)&#123; return a.power&lt;b.power;&#125;for(int i=0;i&lt;n;i++)&#123; father[i]=i;&#125;int find(x)&#123; return pre[x]==x?x,find(pre[x]);&#125;int combine(int x,int y,int i)&#123; int fx=find(x); int fy=find(y); if(fx!=fy)&#123; pre[fx]=fy; sum+=node[i].power;&#125;int main(int argc, char const *argv[])&#123; while(cin&gt;&gt;n&gt;&gt;m)&#123; sum=0; int j=0; for (int i = 0; i &lt; m; ++i) &#123; cin&gt;&gt;node[i].start&gt;&gt;node[i].end&gt;&gt;node[i].power; &#125; sort(node,node+m,cmp); for(int i=0;i&lt;m;i++)&#123; if(find(node[i].start!=node[i].end))&#123; a[j]=node[i].start; b[j]=node[i].end; j++; &#125; combine(node[i].start,node[i].start,i); &#125; for(int i=0;i&lt;n-1;i++) cout&lt;&lt;a[i]&lt;&lt;" "&lt;&lt;b[i]&lt;&lt;endl; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵快速幂”]]></title>
    <url>%2Fyzhiwei.github.io%2F2019%2F03%2F06%2F%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E2%80%9D%2F</url>
    <content type="text"><![CDATA[定义任意个矩阵相乘即为矩阵快速幂 代码实现的思路首先，我们可以用一个结构体来储存我们我们需要的矩阵，用一个结构体数组来保存我们最终需要的那一个矩阵。 具体一些代码块矩阵的定义123struct juzhen&#123; int a[20][20];&#125; //这个就代表了一个矩阵 矩阵相乘表示1234567int cheng(juzhen a,juzheng b,n)&#123; memset(temp,0,sizeof(temp)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) for(int k=0;k&lt;n;k++) temp[i][j]=a[i][k]*b[k][j];&#125; //实现两个矩阵相乘 定义一个单位数组res1234567for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++) if(i==j) juzhen.res[i][j]=1; else juzhen.res[i][j]=1;&#125; 实现n阶，k个矩阵相乘1234567while(k!=0)&#123; if(k&amp;1==1)&#123; res=cheng(res,a,n)； &#125; a=cheng(a,a,n); n=n&gt;&gt;1; //n=n/2;&#125; 此时res即为我们最后得到的矩阵一段完整的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;long long t, n;struct Matrix&#123; int m[20][20];&#125;; //定义结构体矩阵Matrix mul(Matrix a, Matrix b, int t)&#123; Matrix temp; for (int i = 0; i &lt; t; i++) for (int j = 0; j &lt; t; j++) &#123; temp.m[i][j] = 0; &#125; for (int i = 0; i &lt; t; i++) for (int j = 0; j &lt; t; j++) for (int k = 0; k &lt; t; k++) &#123; temp.m[i][j] = (temp.m[i][j] + (a.m[i][k]*b.m[k][j]) % 9973) % 9973; &#125; return temp;&#125; //计算两个n阶矩阵相乘int main(int argc, char const *argv[])&#123; int T; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; t &gt;&gt; n; //cout &lt;&lt; t &lt;&lt; n &lt;&lt; endl; Matrix ans; for (int i = 0; i &lt; t; i++) for (int j = 0; j &lt; t; j++) &#123; if (i == j) ans.m[i][j] = 1; else ans.m[i][j] = 0; &#125;//定义一个单位数组 Matrix a; for (int i = 0; i &lt; t; i++) for (int j = 0; j &lt; t; j++) cin &gt;&gt; a.m[i][j]; while (n != 0) &#123; if (n &amp; 1 == 1) &#123; ans = mul(ans, a, t); &#125;a = mul(a,a,t); n = n&gt;&gt;1; &#125; //计算n个矩阵相乘 /*for (int i = 0; i &lt; t; i++) &#123; for (int j = 0; j &lt; t; j++) cout &lt;&lt; ans.m[i][j] &lt;&lt; " "; cout &lt;&lt; endl; &#125;*/ int x = 0; for (int i = 0; i &lt; t; i++) for (int j = 0; j &lt; t; j++) &#123; if (i == j) x = (x + ans.m[i][j]) % 9973; &#125; cout &lt;&lt; x &lt;&lt; endl; &#125; //取矩阵对角线元素之和 return 0;&#125;]]></content>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷宫问题（dfs）]]></title>
    <url>%2Fyzhiwei.github.io%2F2019%2F02%2F27%2F%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%EF%BC%88dfs%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题概述给定迷宫中起点和终点，以及可以走的格子及不能走的格子，输出任意一条路径。 输入输出输入 T…. ….. **…S 输出 mmm.. ..m.. **mmmS codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;string maze[100];bool vis[100][100]; //判断是否走过bool in(int x,int y) &#123; return x&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&gt;=0&amp;&amp;y&lt;m;&#125; //判断是否出界int a[4][2]=&#123;&#123;-1,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;&#125;; //四个方向搜索bool dfs(int x,int y)&#123; if(maze[x][y]=='S') return true; vis[x][y]=1; maze[x][y]='m'; int tx,ty; for(int i=0;i&lt;4;i++) &#123; tx=x+a[i][0]; ty=y+a[i][1]; if(in(tx,ty)&amp;&amp;maze[tx][ty]!='*'&amp;&amp;!vis[tx][ty])&#123; if(dfs(tx,ty))&#123; return true; &#125; &#125; &#125; vis[x][y]=0; maze[x][y]='.'; return false;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) cin&gt;&gt;maze[i]; int x,y; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(maze[i][j]=='T') &#123; x=i; y=j; &#125; &#125; &#125; if(dfs(x,y))&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++) &#123; cout&lt;&lt;maze[i][j]; &#125; cout&lt;&lt;endl; &#125; &#125; else&#123; cout&lt;&lt;"error"&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[n皇后问题]]></title>
    <url>%2Fyzhiwei.github.io%2F2019%2F01%2F30%2Fn%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目Problem Description在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。你的任务是，对于给定的N，求出有多少种合法的放置方法。 Input 共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。 Output 共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。 Sample Input1850 Sample Output19210 思路要求不在同一行，同一列，对角线上我们可以开一个数组，用数组的下标表示不在同一行，那么不在同一列则是对与下标不同的值他的值也不同在对角线上不同我们可以采用他们的纵坐标的差不等于横坐标的差来表示 代码实现#include&lt;bits/stdc++.h&gt; using namespace std; int x[15],y[15]={0},n,sum; bool place(int k) { for(int i=1;i&lt;k;i++) { if(x[k]==x[i]||abs(x[k]-x[i])==abs(k-i)) return 0; } return 1; } void dfs(int a) { int i; if(i&gt;n) sum++; else for(int i=1;i&lt;=n;i++) { x[a]=i; if(place(a)) dfs(a+1); } } int main() { int j; for(int i=1;i&lt;=10;i++) { n=i; sum=0; dfs(1); y[i]=sum; } while(cin&gt;&gt;j&amp;&amp;j) { cout&lt;&lt;y[j]&lt;&lt;endl; } return 0; } 体会这些老火的深搜题，其实题都是很好懂的，也很好看出来应该在那些地方剪枝，但总感觉代码实现很有难度，应该还是自己敲的次数太少了吧。]]></content>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[独立数据结构和算法—stl]]></title>
    <url>%2Fyzhiwei.github.io%2F2019%2F01%2F30%2F%E7%8B%AC%E7%AB%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E2%80%94stl%2F</url>
    <content type="text"><![CDATA[stl独立于数据结构和算法，体现了泛型编程的思想。 stl组成stl包含迭代器，容器，算法，函数对象，适配器 迭代器连接算法和容器之间的纽带。 容器物所属的地方 算法这个没啥子可说的 函数对象重载了operator（）运算符的对象 适配器通过特定组合的容器实现的一种新的数据结构 本篇重点-算法sort排序第一种情况#include &lt;bits/stdc++.h&gt; using namespace std; int main() { int a[]={1,5,3,6,4}; sort(a,a+sizeof(a)/sizeof(int)); for (int i = 0; i &lt; sizeof(a)/sizeof(int); ++i) { cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; } return 0; } 这是最简单的一种情况，将一个数组从大到小排序这当中不一定是对全部内容进行排序，可以对部分连续数组进行排序，规则为左闭右开。 第二种情况#include &lt;bits/stdc++.h&gt; using namespace std; int main() { int a[]={1,5,3,6,4}; sort(a,a+sizeof(a)/sizeof(int),greater&lt;int&gt;()); for (int i = 0; i &lt; sizeof(a)/sizeof(int); ++i) { cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; } return 0; } 这一种用了greater,将数组给从大到小输出 第三种情况#include &lt;bits/stdc++.h&gt; using namespace std; struct fun { bool operator() (const int &amp;a,const int &amp;b){ return a%10&gt;b%10; } }; int main() { int a[]={19,51,32,6,4}; sort(a,a+sizeof(a)/sizeof(int),fun()); for (int i = 0; i &lt; sizeof(a)/sizeof(int); ++i) { cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; } return 0; } 这当中采用了自定义规则排序，主要是要注意自定义规则的写法。]]></content>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深搜题（hdu1455)]]></title>
    <url>%2Fyzhiwei.github.io%2F2019%2F01%2F27%2F%E6%B7%B1%E6%90%9C%E9%A2%98%EF%BC%88hdu1455%2F</url>
    <content type="text"><![CDATA[题面Problem DescriptionGeorge took sticks of the same length and cut them randomly until all parts became at most 50 units long. Now he wants to return sticks to the original state, but he forgot how many sticks he had originally and how long they were originally. Please help him and design a program which computes the smallest possible original length of those sticks. All lengths expressed in units are integers greater than zero. InputThe input contains blocks of 2 lines. The first line contains the number of sticks parts after cutting, there are at most 64 sticks. The second line contains the lengths of those parts separated by the space. The last line of the file contains zero. OutputThe output file contains the smallest possible length of original sticks, one per line. Sample Input95 2 1 5 2 1 5 2 141 2 3 40 Sample Output6 5 题意给定n个已经被分割棒子的长度，如题面中的1，2，3，4.代表4个被分割绳子的长度，要求求出原绳子的最小长度（原绳子等长）即本题绳子长度为5，5=2+3，5=1+4 分析首先我们应该确定绳子的长度，绳子的最小长度应该为被分割绳子的最长长度，绳子的最大长度应该为被分割绳子的总长度max（1，2，3，4）&lt;绳长&lt;sum(1,2,3,4) 下面我们应该应该排除一些情况1.sum=10，那么绳长就不应该是9，8，7，6，4，32.max=4，那么绳长就不应该是1，2，3综合以上情况，绳长的可能性应该是9，8，7，6，4 下面就应该是对绳子组合的一些具体排除（要对绳子长度从大到小排序） 如绳子长度为8，7，3，2我们选取最小值为8，对于7而言，7+1=8，而在后面并没有出现1，此时，我们便可以排除8这一种情况。 若绳子长度为8，6，3，3我们选取最小值为8，对于6而言，6+2=8；此时3不符合情况，对后面的3可以直接跳过 代码实现#include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;algorithm&gt; using namespace std; int n,cnt,sum;//n表示木棍的数量，sum表示n个木棍的总长度，cnt=sum/i; struct node { int lenth ;// 木棍的长度 int mark; //标记这根木棍是否被用过; }stick[66]; int cmp(node a,node b) //按长度从大到小排序 { return a.lenth&gt;b.lenth; } //比较排序 //len为当前木棒的长度，count统计当前长度木棒的数量， int dfs(int len,int count,int l,int pos) { if(len==sum) return 1; //递归出口 if(count==cnt) return 1; //这个写不写都无所谓，上面一行就ok for(int i=pos;i&lt;n;i++) { if(stick[i].mark)continue; //如果木棍被标记过，跳过去 if(len==(stick[i].lenth+l)) { stick[i].mark=1; //修改标记 if(dfs(len,count+1,0,0)) return 1; stick[i].mark=0; //标记还原 return 0; } else if(len&gt;(stick[i].lenth+l)) { stick[i].mark=1; l+=stick[i].lenth; if(dfs(len,count,l,i+1)) return 1; l-=stick[i].lenth; //如果不能拼接，那么就恢复 stick[i].mark=0; if(l==0) return 0; while(stick[i].lenth==stick[i+1].lenth)i++; //这是一条非常重要的剪枝，可以极大的降低时间复杂度 return 0; } int main() { while(cin&gt;&gt;n&amp;&amp;n) { cnt=sum=0; for(int i=0;i&lt;n;i++) { cin&gt;&gt;stick[i].lenth; sum+=stick[i].lenth; stick[i].mark=0; //初始标记为0 } sort(stick,stick+n,cmp); //对长度进行排序 for(int i=stick[0].lenth;i&lt;=sum;i++) { if(sum%i)continue; //对长度进行选择 cnt=sum/i; if(dfs(i,0,0,0)) { printf(&quot;%d\n&quot;,i); break; } } } return 0; } dfs最关键的代码结构块void dfs()//参数用来表示状态 { if(到达终点状态) { ...//根据题意添加 return; } if(越界或者是不合法状态) return; if(特殊状态)//剪枝 return ; for(扩展方式) { if(扩展方式所达到状态合法) { 修改操作;//根据题意来添加 标记； dfs（）； (还原标记)； //是否还原标记根据题意 //如果加上（还原标记）就是 回溯法 } } } 思考这是做过的第一道深搜题，还是不能够完全理解递归的过程。dfs题型很多，需要多多总结。 sort排序的一种新形式get]]></content>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将sublime用来写c/c++程序]]></title>
    <url>%2Fyzhiwei.github.io%2F2019%2F01%2F27%2F%E5%B0%86sublime%E7%94%A8%E6%9D%A5%E5%86%99c-c-%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[sublime简介sublime是一个文本编辑软件，相当于电脑自带的记事本，但因其有很高的颜值，深受人们喜爱，但作为程序员来讲，学会用sublime写代码是一件很赏心悦目的事情。 具体步骤编译器的安装如果你的电脑中带有vs，codeblock等软件，你需要找到一个名为GW的文件夹，并将它复制到C盘根目录下面如果你的电脑中没有编译软件，那么你需要在网上下载GW文件。 环境变量配置打开此电脑-属性-高级系统设置-环境变量-系统变量将C:\MinGW64\bin加入到path中 sublime中的设置依次打开tools-build system—new build system输入以下代码： { //&quot;shell_cmd&quot;: &quot;make&quot; &quot;working_dir&quot;: &quot;$file_path&quot;, &quot;cmd&quot;: &quot;gcc -Wall \&quot;$file_name\&quot; -o \&quot;$file_base_name\&quot;&quot;, &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;, &quot;selector&quot;: &quot;source.c&quot;, &quot;variants&quot;: [ { &quot;name&quot;: &quot;Run&quot;, &quot;shell_cmd&quot;: &quot;gcc -Wall \&quot;$file\&quot; -o \&quot;$file_base_name\&quot; &amp;&amp; \&quot;${file_path}/${file_base_name}\&quot;&quot; } ] } ctrl+s 保存，名字随意就好 运行你的c/c++程序 tools-build with ctrl shift b 一些可以改进的地方快捷键的设置 许多人习惯了采用vs和dev这些编译器，希望只用一个f9便能够编译加运行，此时，我们在添加一行代码就好。 [ {“keys”: [“f9”], “command”: “build”, “args”: {“variant”: “RunInCommand”}} ]]]></content>
      <tags>
        <tag>软件使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写于博客建成之后]]></title>
    <url>%2Fyzhiwei.github.io%2F2019%2F01%2F24%2F%E5%86%99%E4%BA%8E%E5%8D%9A%E5%AE%A2%E5%BB%BA%E6%88%90%E4%B9%8B%E5%90%8E%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fyzhiwei.github.io%2F2019%2F01%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
